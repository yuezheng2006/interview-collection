# 认证问题排查指南

## 问题描述

流式AI接口报错："无效的认证令牌"，而其他接口正常工作。

## 问题分析

### 1. Token存储不一致
- **auth.ts**: 使用 `localStorage.setItem('auth-token', token)`
- **流式请求**: 使用 `localStorage.getItem('token')` (错误的key)

### 2. Token格式不一致
- **api.ts (axios)**: 直接使用 `store.token` (无Bearer前缀)
- **流式请求**: 使用 `Bearer ${token}` (有Bearer前缀)

### 3. 认证中间件处理
- 后端中间件期望处理Bearer格式，但前端发送的格式不一致

## 解决方案

### 1. 统一Token存储key
```typescript
// 修复前
const token = localStorage.getItem('token') || ''

// 修复后
const token = localStorage.getItem('auth-token') || ''
```

### 2. 统一Token格式
```typescript
// 修复前
'Authorization': `Bearer ${token}`

// 修复后
'Authorization': token  // 直接使用token，与axios保持一致
```

### 3. 后端认证中间件优化
```go
// 支持两种格式：纯token和Bearer token
func requireAuth() gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.AbortWithStatusJSON(401, gin.H{"error": "缺少认证令牌"})
            return
        }
        
        // 处理Bearer token格式
        var token string
        if len(authHeader) > 7 && authHeader[:7] == "Bearer " {
            token = authHeader[7:] // 去掉"Bearer "前缀
        } else {
            token = authHeader // 如果没有Bearer前缀，直接使用
        }
        
        // ... 验证token
    }
}
```

## 修复后的代码

### 前端流式请求
```typescript
export async function callUnifiedAIStream(
  data: UnifiedAiRequest, 
  callback: StreamCallback
): Promise<void> {
  try {
    const apiUrl = '/api/ai/unified'
    
    // 获取认证token，与api.ts保持一致
    const token = localStorage.getItem('auth-token') || ''
    
    const response = await fetch(apiUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': token, // 直接使用token，不加Bearer前缀
        'Accept': 'text/event-stream',
        'Cache-Control': 'no-cache',
        'Connection': 'keep-alive'
      },
      body: JSON.stringify({
        ...data,
        stream: true
      })
    })
    
    // ... 处理响应
  } catch (error) {
    console.error('流式AI调用失败:', error)
    throw error
  }
}
```

### 后端认证中间件
```go
func requireAuth() gin.HandlerFunc {
    return func(c *gin.Context) {
        authHeader := c.GetHeader("Authorization")
        if authHeader == "" {
            c.AbortWithStatusJSON(401, gin.H{"error": "缺少认证令牌"})
            return
        }
        
        // 处理Bearer token格式
        var token string
        if len(authHeader) > 7 && authHeader[:7] == "Bearer " {
            token = authHeader[7:] // 去掉"Bearer "前缀
        } else {
            token = authHeader // 如果没有Bearer前缀，直接使用
        }
        
        if token == "" {
            c.AbortWithStatusJSON(401, gin.H{"error": "无效的认证令牌"})
            return
        }
        
        username, err := parseJWT(token)
        if err != nil || username == "" {
            c.AbortWithStatusJSON(401, gin.H{"error": "无效的认证令牌"})
            return
        }
        c.Set("username", username)
        c.Next()
    }
}
```

## 验证步骤

### 1. 检查Token存储
在浏览器控制台中验证：
```javascript
// 应该返回实际的token值
console.log('auth-token:', localStorage.getItem('auth-token'))
console.log('token:', localStorage.getItem('token')) // 应该返回null
```

### 2. 检查请求头
在浏览器开发者工具的Network面板中：
1. 发起流式AI请求
2. 查看请求头中的Authorization字段
3. 确认格式与axios请求一致

### 3. 检查后端日志
查看后端是否收到正确的认证头：
```go
log.Printf("Authorization header: %s", c.GetHeader("Authorization"))
```

## 常见问题

### 1. Token过期
- 检查token是否过期
- 重新登录获取新token

### 2. 存储问题
- 确认localStorage是否可用
- 检查是否有其他代码清空了token

### 3. 跨域问题
- 确认CORS配置正确
- 检查预检请求是否通过

## 调试技巧

### 1. 前端调试
```typescript
// 在流式请求前添加调试信息
console.log('Token:', token)
console.log('Request URL:', apiUrl)
console.log('Request headers:', {
  'Content-Type': 'application/json',
  'Authorization': token,
  'Accept': 'text/event-stream'
})
```

### 2. 后端调试
```go
// 在认证中间件中添加调试信息
log.Printf("Request path: %s", c.Request.URL.Path)
log.Printf("Authorization header: %s", c.GetHeader("Authorization"))
log.Printf("Parsed token: %s", token)
```

### 3. 网络调试
- 使用浏览器开发者工具的Network面板
- 检查请求和响应的详细信息
- 确认代理配置正确

## 预期结果

修复后：
1. 流式AI请求应该能正确发送认证头
2. 后端应该能正确解析token
3. 认证应该通过，不再报"无效的认证令牌"错误
4. 流式AI功能应该正常工作

## 总结

认证问题主要是由于：
1. Token存储key不一致
2. Token格式不一致
3. 前后端认证处理不匹配

通过统一token存储和格式，以及优化后端认证中间件，可以解决这个问题。 